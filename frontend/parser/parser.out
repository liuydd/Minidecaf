Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program element
Rule 3     element -> function
Rule 4     element -> declaration Semi
Rule 5     program -> empty
Rule 6     type -> Int
Rule 7     function -> type Identifier LParen parameter RParen LBrace block RBrace
Rule 8     parameter -> parameter params
Rule 9     parameter -> empty
Rule 10    params -> Comma declaration
Rule 11    params -> declaration
Rule 12    params -> type Identifier dim_list
Rule 13    block -> block block_item
Rule 14    block -> empty
Rule 15    block_item -> statement
Rule 16    block_item -> declaration Semi
Rule 17    statement -> statement_matched
Rule 18    statement -> statement_unmatched
Rule 19    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 20    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 21    statement_unmatched -> If LParen expression RParen statement
Rule 22    statement_matched -> While LParen expression RParen statement_matched
Rule 23    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 24    statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched
Rule 25    statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched
Rule 26    statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched
Rule 27    statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched
Rule 28    statement_matched -> Return expression Semi
Rule 29    statement_matched -> opt_expression Semi
Rule 30    statement_matched -> LBrace block RBrace
Rule 31    statement_matched -> Break Semi
Rule 32    statement_matched -> Continue Semi
Rule 33    opt_expression -> expression
Rule 34    opt_expression -> empty
Rule 35    declaration -> type Identifier
Rule 36    declaration -> type Identifier Assign expression
Rule 37    declaration -> type Identifier dim_list
Rule 38    dim_list -> LBracket RBracket
Rule 39    dim_list -> LBracket Integer RBracket
Rule 40    dim_list -> dim_list LBracket Integer RBracket
Rule 41    declaration -> type Identifier dim_list Assign init_list
Rule 42    init_list -> LBrace init_elem RBrace
Rule 43    init_elem -> Integer
Rule 44    init_elem -> init_elem Comma Integer
Rule 45    expression -> assignment
Rule 46    assignment -> conditional
Rule 47    conditional -> logical_or
Rule 48    logical_or -> logical_and
Rule 49    logical_and -> bit_or
Rule 50    bit_or -> xor
Rule 51    xor -> bit_and
Rule 52    bit_and -> equality
Rule 53    equality -> relational
Rule 54    relational -> additive
Rule 55    additive -> multiplicative
Rule 56    multiplicative -> unary
Rule 57    unary -> postfix
Rule 58    postfix -> primary
Rule 59    expression_list -> expression_list exprs
Rule 60    expression_list -> empty
Rule 61    exprs -> Comma expression
Rule 62    exprs -> expression
Rule 63    postfix -> Identifier LParen expression_list RParen
Rule 64    postfix -> postfix LBracket expression RBracket
Rule 65    unary -> Minus unary
Rule 66    unary -> BitNot unary
Rule 67    unary -> Not unary
Rule 68    assignment -> postfix Assign expression
Rule 69    logical_or -> logical_or Or logical_and
Rule 70    logical_and -> logical_and And bit_or
Rule 71    bit_or -> bit_or BitOr xor
Rule 72    xor -> xor Xor bit_and
Rule 73    bit_and -> bit_and BitAnd equality
Rule 74    equality -> equality NotEqual relational
Rule 75    equality -> equality Equal relational
Rule 76    relational -> relational Less additive
Rule 77    relational -> relational Greater additive
Rule 78    relational -> relational LessEqual additive
Rule 79    relational -> relational GreaterEqual additive
Rule 80    additive -> additive Plus multiplicative
Rule 81    additive -> additive Minus multiplicative
Rule 82    multiplicative -> multiplicative Mul unary
Rule 83    multiplicative -> multiplicative Div unary
Rule 84    multiplicative -> multiplicative Mod unary
Rule 85    conditional -> logical_or Question expression Colon conditional
Rule 86    primary -> Integer
Rule 87    primary -> Identifier
Rule 88    primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 70
Assign               : 36 41 68
BitAnd               : 73
BitNot               : 66
BitOr                : 71
Break                : 31
Colon                : 85
Comma                : 10 44 61
Continue             : 32
Div                  : 83
Else                 : 19 20
Equal                : 75
For                  : 24 25 26 27
Greater              : 77
GreaterEqual         : 79
Identifier           : 7 12 35 36 37 41 63 87
If                   : 19 20 21
Int                  : 6
Integer              : 39 40 43 44 86
LBrace               : 7 30 42
LBracket             : 38 39 40 64
LParen               : 7 19 20 21 22 23 24 25 26 27 63 88
Less                 : 76
LessEqual            : 78
Minus                : 65 81
Mod                  : 84
Mul                  : 82
Not                  : 67
NotEqual             : 74
Or                   : 69
Plus                 : 80
Question             : 85
RBrace               : 7 30 42
RBracket             : 38 39 40 64
RParen               : 7 19 20 21 22 23 24 25 26 27 63 88
Return               : 28
Semi                 : 4 16 24 24 25 25 26 26 27 27 28 29 31 32
While                : 22 23
Xor                  : 72
error                : 

Nonterminals, with rules where they appear

additive             : 54 76 77 78 79 80 81
assignment           : 45
bit_and              : 51 72 73
bit_or               : 49 70 71
block                : 7 13 30
block_item           : 13
conditional          : 46 85
declaration          : 4 10 11 16 25 27
dim_list             : 12 37 40 41
element              : 2
empty                : 5 9 14 34 60
equality             : 52 73 74 75
expression           : 19 20 21 22 23 24 24 24 25 25 26 26 26 27 27 28 33 36 61 62 64 68 85 88
expression_list      : 59 63
exprs                : 59
function             : 3
init_elem            : 42 44
init_list            : 41
logical_and          : 48 69 70
logical_or           : 47 69 85
multiplicative       : 55 80 81 82 83 84
opt_expression       : 29
parameter            : 7 8
params               : 8
postfix              : 57 64 68
primary              : 58
program              : 2 0
relational           : 53 74 75 76 77 78 79
statement            : 15 21
statement_matched    : 17 19 19 20 22 24 25
statement_unmatched  : 18 20 23 26 27
type                 : 7 12 35 36 37 41
unary                : 56 65 66 67 82 83 84
xor                  : 50 71 72

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program element
    (5) program -> . empty
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . element
    (3) element -> . function
    (4) element -> . declaration Semi
    (7) function -> . type Identifier LParen parameter RParen LBrace block RBrace
    (35) declaration -> . type Identifier
    (36) declaration -> . type Identifier Assign expression
    (37) declaration -> . type Identifier dim_list
    (41) declaration -> . type Identifier dim_list Assign init_list
    (6) type -> . Int

    Int             shift and go to state 7

    element                        shift and go to state 3
    function                       shift and go to state 4
    declaration                    shift and go to state 5
    type                           shift and go to state 6

state 2

    (5) program -> empty .

    Int             reduce using rule 5 (program -> empty .)
    $end            reduce using rule 5 (program -> empty .)


state 3

    (2) program -> program element .

    Int             reduce using rule 2 (program -> program element .)
    $end            reduce using rule 2 (program -> program element .)


state 4

    (3) element -> function .

    Int             reduce using rule 3 (element -> function .)
    $end            reduce using rule 3 (element -> function .)


state 5

    (4) element -> declaration . Semi

    Semi            shift and go to state 8


state 6

    (7) function -> type . Identifier LParen parameter RParen LBrace block RBrace
    (35) declaration -> type . Identifier
    (36) declaration -> type . Identifier Assign expression
    (37) declaration -> type . Identifier dim_list
    (41) declaration -> type . Identifier dim_list Assign init_list

    Identifier      shift and go to state 9


state 7

    (6) type -> Int .

    Identifier      reduce using rule 6 (type -> Int .)


state 8

    (4) element -> declaration Semi .

    Int             reduce using rule 4 (element -> declaration Semi .)
    $end            reduce using rule 4 (element -> declaration Semi .)


state 9

    (7) function -> type Identifier . LParen parameter RParen LBrace block RBrace
    (35) declaration -> type Identifier .
    (36) declaration -> type Identifier . Assign expression
    (37) declaration -> type Identifier . dim_list
    (41) declaration -> type Identifier . dim_list Assign init_list
    (38) dim_list -> . LBracket RBracket
    (39) dim_list -> . LBracket Integer RBracket
    (40) dim_list -> . dim_list LBracket Integer RBracket

    LParen          shift and go to state 10
    Semi            reduce using rule 35 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 13

    dim_list                       shift and go to state 12

state 10

    (7) function -> type Identifier LParen . parameter RParen LBrace block RBrace
    (8) parameter -> . parameter params
    (9) parameter -> . empty
    (1) empty -> .

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)

    parameter                      shift and go to state 14
    empty                          shift and go to state 15

state 11

    (36) declaration -> type Identifier Assign . expression
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 17
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 12

    (37) declaration -> type Identifier dim_list .
    (41) declaration -> type Identifier dim_list . Assign init_list
    (40) dim_list -> dim_list . LBracket Integer RBracket

    Semi            reduce using rule 37 (declaration -> type Identifier dim_list .)
    RParen          reduce using rule 37 (declaration -> type Identifier dim_list .)
    Comma           reduce using rule 37 (declaration -> type Identifier dim_list .)
    Int             reduce using rule 37 (declaration -> type Identifier dim_list .)
    Assign          shift and go to state 37
    LBracket        shift and go to state 38


state 13

    (38) dim_list -> LBracket . RBracket
    (39) dim_list -> LBracket . Integer RBracket

    RBracket        shift and go to state 39
    Integer         shift and go to state 40


state 14

    (7) function -> type Identifier LParen parameter . RParen LBrace block RBrace
    (8) parameter -> parameter . params
    (10) params -> . Comma declaration
    (11) params -> . declaration
    (12) params -> . type Identifier dim_list
    (35) declaration -> . type Identifier
    (36) declaration -> . type Identifier Assign expression
    (37) declaration -> . type Identifier dim_list
    (41) declaration -> . type Identifier dim_list Assign init_list
    (6) type -> . Int

    RParen          shift and go to state 42
    Comma           shift and go to state 44
    Int             shift and go to state 7

    type                           shift and go to state 41
    params                         shift and go to state 43
    declaration                    shift and go to state 45

state 15

    (9) parameter -> empty .

    RParen          reduce using rule 9 (parameter -> empty .)
    Comma           reduce using rule 9 (parameter -> empty .)
    Int             reduce using rule 9 (parameter -> empty .)


state 16

    (63) postfix -> Identifier . LParen expression_list RParen
    (87) primary -> Identifier .

  ! shift/reduce conflict for LParen resolved as shift
    LParen          shift and go to state 46
    Assign          reduce using rule 87 (primary -> Identifier .)
    LBracket        reduce using rule 87 (primary -> Identifier .)
    Mul             reduce using rule 87 (primary -> Identifier .)
    Div             reduce using rule 87 (primary -> Identifier .)
    Mod             reduce using rule 87 (primary -> Identifier .)
    Plus            reduce using rule 87 (primary -> Identifier .)
    Minus           reduce using rule 87 (primary -> Identifier .)
    Less            reduce using rule 87 (primary -> Identifier .)
    Greater         reduce using rule 87 (primary -> Identifier .)
    LessEqual       reduce using rule 87 (primary -> Identifier .)
    GreaterEqual    reduce using rule 87 (primary -> Identifier .)
    NotEqual        reduce using rule 87 (primary -> Identifier .)
    Equal           reduce using rule 87 (primary -> Identifier .)
    BitAnd          reduce using rule 87 (primary -> Identifier .)
    Xor             reduce using rule 87 (primary -> Identifier .)
    BitOr           reduce using rule 87 (primary -> Identifier .)
    And             reduce using rule 87 (primary -> Identifier .)
    Question        reduce using rule 87 (primary -> Identifier .)
    Or              reduce using rule 87 (primary -> Identifier .)
    Semi            reduce using rule 87 (primary -> Identifier .)
    RParen          reduce using rule 87 (primary -> Identifier .)
    Comma           reduce using rule 87 (primary -> Identifier .)
    Int             reduce using rule 87 (primary -> Identifier .)
    RBracket        reduce using rule 87 (primary -> Identifier .)
    Colon           reduce using rule 87 (primary -> Identifier .)
    Identifier      reduce using rule 87 (primary -> Identifier .)
    Integer         reduce using rule 87 (primary -> Identifier .)
    BitNot          reduce using rule 87 (primary -> Identifier .)
    Not             reduce using rule 87 (primary -> Identifier .)

  ! LParen          [ reduce using rule 87 (primary -> Identifier .) ]


state 17

    (36) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 36 (declaration -> type Identifier Assign expression .)
    RParen          reduce using rule 36 (declaration -> type Identifier Assign expression .)
    Comma           reduce using rule 36 (declaration -> type Identifier Assign expression .)
    Int             reduce using rule 36 (declaration -> type Identifier Assign expression .)


state 18

    (45) expression -> assignment .

    Semi            reduce using rule 45 (expression -> assignment .)
    RParen          reduce using rule 45 (expression -> assignment .)
    Comma           reduce using rule 45 (expression -> assignment .)
    Int             reduce using rule 45 (expression -> assignment .)
    RBracket        reduce using rule 45 (expression -> assignment .)
    Colon           reduce using rule 45 (expression -> assignment .)
    Identifier      reduce using rule 45 (expression -> assignment .)
    Integer         reduce using rule 45 (expression -> assignment .)
    LParen          reduce using rule 45 (expression -> assignment .)
    Minus           reduce using rule 45 (expression -> assignment .)
    BitNot          reduce using rule 45 (expression -> assignment .)
    Not             reduce using rule 45 (expression -> assignment .)


state 19

    (46) assignment -> conditional .

    Semi            reduce using rule 46 (assignment -> conditional .)
    RParen          reduce using rule 46 (assignment -> conditional .)
    Comma           reduce using rule 46 (assignment -> conditional .)
    Int             reduce using rule 46 (assignment -> conditional .)
    RBracket        reduce using rule 46 (assignment -> conditional .)
    Colon           reduce using rule 46 (assignment -> conditional .)
    Identifier      reduce using rule 46 (assignment -> conditional .)
    Integer         reduce using rule 46 (assignment -> conditional .)
    LParen          reduce using rule 46 (assignment -> conditional .)
    Minus           reduce using rule 46 (assignment -> conditional .)
    BitNot          reduce using rule 46 (assignment -> conditional .)
    Not             reduce using rule 46 (assignment -> conditional .)


state 20

    (68) assignment -> postfix . Assign expression
    (64) postfix -> postfix . LBracket expression RBracket
    (57) unary -> postfix .

    Assign          shift and go to state 47
    LBracket        shift and go to state 48
    Mul             reduce using rule 57 (unary -> postfix .)
    Div             reduce using rule 57 (unary -> postfix .)
    Mod             reduce using rule 57 (unary -> postfix .)
    Plus            reduce using rule 57 (unary -> postfix .)
    Minus           reduce using rule 57 (unary -> postfix .)
    Less            reduce using rule 57 (unary -> postfix .)
    Greater         reduce using rule 57 (unary -> postfix .)
    LessEqual       reduce using rule 57 (unary -> postfix .)
    GreaterEqual    reduce using rule 57 (unary -> postfix .)
    NotEqual        reduce using rule 57 (unary -> postfix .)
    Equal           reduce using rule 57 (unary -> postfix .)
    BitAnd          reduce using rule 57 (unary -> postfix .)
    Xor             reduce using rule 57 (unary -> postfix .)
    BitOr           reduce using rule 57 (unary -> postfix .)
    And             reduce using rule 57 (unary -> postfix .)
    Question        reduce using rule 57 (unary -> postfix .)
    Or              reduce using rule 57 (unary -> postfix .)
    Semi            reduce using rule 57 (unary -> postfix .)
    RParen          reduce using rule 57 (unary -> postfix .)
    Comma           reduce using rule 57 (unary -> postfix .)
    Int             reduce using rule 57 (unary -> postfix .)
    RBracket        reduce using rule 57 (unary -> postfix .)
    Colon           reduce using rule 57 (unary -> postfix .)
    Identifier      reduce using rule 57 (unary -> postfix .)
    Integer         reduce using rule 57 (unary -> postfix .)
    LParen          reduce using rule 57 (unary -> postfix .)
    BitNot          reduce using rule 57 (unary -> postfix .)
    Not             reduce using rule 57 (unary -> postfix .)


state 21

    (47) conditional -> logical_or .
    (85) conditional -> logical_or . Question expression Colon conditional
    (69) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 47 (conditional -> logical_or .)
    RParen          reduce using rule 47 (conditional -> logical_or .)
    Comma           reduce using rule 47 (conditional -> logical_or .)
    Int             reduce using rule 47 (conditional -> logical_or .)
    RBracket        reduce using rule 47 (conditional -> logical_or .)
    Colon           reduce using rule 47 (conditional -> logical_or .)
    Identifier      reduce using rule 47 (conditional -> logical_or .)
    Integer         reduce using rule 47 (conditional -> logical_or .)
    LParen          reduce using rule 47 (conditional -> logical_or .)
    Minus           reduce using rule 47 (conditional -> logical_or .)
    BitNot          reduce using rule 47 (conditional -> logical_or .)
    Not             reduce using rule 47 (conditional -> logical_or .)
    Question        shift and go to state 49
    Or              shift and go to state 50


state 22

    (58) postfix -> primary .

    Assign          reduce using rule 58 (postfix -> primary .)
    LBracket        reduce using rule 58 (postfix -> primary .)
    Mul             reduce using rule 58 (postfix -> primary .)
    Div             reduce using rule 58 (postfix -> primary .)
    Mod             reduce using rule 58 (postfix -> primary .)
    Plus            reduce using rule 58 (postfix -> primary .)
    Minus           reduce using rule 58 (postfix -> primary .)
    Less            reduce using rule 58 (postfix -> primary .)
    Greater         reduce using rule 58 (postfix -> primary .)
    LessEqual       reduce using rule 58 (postfix -> primary .)
    GreaterEqual    reduce using rule 58 (postfix -> primary .)
    NotEqual        reduce using rule 58 (postfix -> primary .)
    Equal           reduce using rule 58 (postfix -> primary .)
    BitAnd          reduce using rule 58 (postfix -> primary .)
    Xor             reduce using rule 58 (postfix -> primary .)
    BitOr           reduce using rule 58 (postfix -> primary .)
    And             reduce using rule 58 (postfix -> primary .)
    Question        reduce using rule 58 (postfix -> primary .)
    Or              reduce using rule 58 (postfix -> primary .)
    Semi            reduce using rule 58 (postfix -> primary .)
    RParen          reduce using rule 58 (postfix -> primary .)
    Comma           reduce using rule 58 (postfix -> primary .)
    Int             reduce using rule 58 (postfix -> primary .)
    RBracket        reduce using rule 58 (postfix -> primary .)
    Colon           reduce using rule 58 (postfix -> primary .)
    Identifier      reduce using rule 58 (postfix -> primary .)
    Integer         reduce using rule 58 (postfix -> primary .)
    LParen          reduce using rule 58 (postfix -> primary .)
    BitNot          reduce using rule 58 (postfix -> primary .)
    Not             reduce using rule 58 (postfix -> primary .)


state 23

    (88) primary -> LParen . expression RParen
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 51
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 24

    (48) logical_or -> logical_and .
    (70) logical_and -> logical_and . And bit_or

    Question        reduce using rule 48 (logical_or -> logical_and .)
    Or              reduce using rule 48 (logical_or -> logical_and .)
    Semi            reduce using rule 48 (logical_or -> logical_and .)
    RParen          reduce using rule 48 (logical_or -> logical_and .)
    Comma           reduce using rule 48 (logical_or -> logical_and .)
    Int             reduce using rule 48 (logical_or -> logical_and .)
    RBracket        reduce using rule 48 (logical_or -> logical_and .)
    Colon           reduce using rule 48 (logical_or -> logical_and .)
    Identifier      reduce using rule 48 (logical_or -> logical_and .)
    Integer         reduce using rule 48 (logical_or -> logical_and .)
    LParen          reduce using rule 48 (logical_or -> logical_and .)
    Minus           reduce using rule 48 (logical_or -> logical_and .)
    BitNot          reduce using rule 48 (logical_or -> logical_and .)
    Not             reduce using rule 48 (logical_or -> logical_and .)
    And             shift and go to state 52


state 25

    (86) primary -> Integer .

    Assign          reduce using rule 86 (primary -> Integer .)
    LBracket        reduce using rule 86 (primary -> Integer .)
    Mul             reduce using rule 86 (primary -> Integer .)
    Div             reduce using rule 86 (primary -> Integer .)
    Mod             reduce using rule 86 (primary -> Integer .)
    Plus            reduce using rule 86 (primary -> Integer .)
    Minus           reduce using rule 86 (primary -> Integer .)
    Less            reduce using rule 86 (primary -> Integer .)
    Greater         reduce using rule 86 (primary -> Integer .)
    LessEqual       reduce using rule 86 (primary -> Integer .)
    GreaterEqual    reduce using rule 86 (primary -> Integer .)
    NotEqual        reduce using rule 86 (primary -> Integer .)
    Equal           reduce using rule 86 (primary -> Integer .)
    BitAnd          reduce using rule 86 (primary -> Integer .)
    Xor             reduce using rule 86 (primary -> Integer .)
    BitOr           reduce using rule 86 (primary -> Integer .)
    And             reduce using rule 86 (primary -> Integer .)
    Question        reduce using rule 86 (primary -> Integer .)
    Or              reduce using rule 86 (primary -> Integer .)
    Semi            reduce using rule 86 (primary -> Integer .)
    RParen          reduce using rule 86 (primary -> Integer .)
    Comma           reduce using rule 86 (primary -> Integer .)
    Int             reduce using rule 86 (primary -> Integer .)
    RBracket        reduce using rule 86 (primary -> Integer .)
    Colon           reduce using rule 86 (primary -> Integer .)
    Identifier      reduce using rule 86 (primary -> Integer .)
    Integer         reduce using rule 86 (primary -> Integer .)
    LParen          reduce using rule 86 (primary -> Integer .)
    BitNot          reduce using rule 86 (primary -> Integer .)
    Not             reduce using rule 86 (primary -> Integer .)


state 26

    (49) logical_and -> bit_or .
    (71) bit_or -> bit_or . BitOr xor

    And             reduce using rule 49 (logical_and -> bit_or .)
    Question        reduce using rule 49 (logical_and -> bit_or .)
    Or              reduce using rule 49 (logical_and -> bit_or .)
    Semi            reduce using rule 49 (logical_and -> bit_or .)
    RParen          reduce using rule 49 (logical_and -> bit_or .)
    Comma           reduce using rule 49 (logical_and -> bit_or .)
    Int             reduce using rule 49 (logical_and -> bit_or .)
    RBracket        reduce using rule 49 (logical_and -> bit_or .)
    Colon           reduce using rule 49 (logical_and -> bit_or .)
    Identifier      reduce using rule 49 (logical_and -> bit_or .)
    Integer         reduce using rule 49 (logical_and -> bit_or .)
    LParen          reduce using rule 49 (logical_and -> bit_or .)
    Minus           reduce using rule 49 (logical_and -> bit_or .)
    BitNot          reduce using rule 49 (logical_and -> bit_or .)
    Not             reduce using rule 49 (logical_and -> bit_or .)
    BitOr           shift and go to state 53


state 27

    (50) bit_or -> xor .
    (72) xor -> xor . Xor bit_and

    BitOr           reduce using rule 50 (bit_or -> xor .)
    And             reduce using rule 50 (bit_or -> xor .)
    Question        reduce using rule 50 (bit_or -> xor .)
    Or              reduce using rule 50 (bit_or -> xor .)
    Semi            reduce using rule 50 (bit_or -> xor .)
    RParen          reduce using rule 50 (bit_or -> xor .)
    Comma           reduce using rule 50 (bit_or -> xor .)
    Int             reduce using rule 50 (bit_or -> xor .)
    RBracket        reduce using rule 50 (bit_or -> xor .)
    Colon           reduce using rule 50 (bit_or -> xor .)
    Identifier      reduce using rule 50 (bit_or -> xor .)
    Integer         reduce using rule 50 (bit_or -> xor .)
    LParen          reduce using rule 50 (bit_or -> xor .)
    Minus           reduce using rule 50 (bit_or -> xor .)
    BitNot          reduce using rule 50 (bit_or -> xor .)
    Not             reduce using rule 50 (bit_or -> xor .)
    Xor             shift and go to state 54


state 28

    (51) xor -> bit_and .
    (73) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 51 (xor -> bit_and .)
    BitOr           reduce using rule 51 (xor -> bit_and .)
    And             reduce using rule 51 (xor -> bit_and .)
    Question        reduce using rule 51 (xor -> bit_and .)
    Or              reduce using rule 51 (xor -> bit_and .)
    Semi            reduce using rule 51 (xor -> bit_and .)
    RParen          reduce using rule 51 (xor -> bit_and .)
    Comma           reduce using rule 51 (xor -> bit_and .)
    Int             reduce using rule 51 (xor -> bit_and .)
    RBracket        reduce using rule 51 (xor -> bit_and .)
    Colon           reduce using rule 51 (xor -> bit_and .)
    Identifier      reduce using rule 51 (xor -> bit_and .)
    Integer         reduce using rule 51 (xor -> bit_and .)
    LParen          reduce using rule 51 (xor -> bit_and .)
    Minus           reduce using rule 51 (xor -> bit_and .)
    BitNot          reduce using rule 51 (xor -> bit_and .)
    Not             reduce using rule 51 (xor -> bit_and .)
    BitAnd          shift and go to state 55


state 29

    (52) bit_and -> equality .
    (74) equality -> equality . NotEqual relational
    (75) equality -> equality . Equal relational

    BitAnd          reduce using rule 52 (bit_and -> equality .)
    Xor             reduce using rule 52 (bit_and -> equality .)
    BitOr           reduce using rule 52 (bit_and -> equality .)
    And             reduce using rule 52 (bit_and -> equality .)
    Question        reduce using rule 52 (bit_and -> equality .)
    Or              reduce using rule 52 (bit_and -> equality .)
    Semi            reduce using rule 52 (bit_and -> equality .)
    RParen          reduce using rule 52 (bit_and -> equality .)
    Comma           reduce using rule 52 (bit_and -> equality .)
    Int             reduce using rule 52 (bit_and -> equality .)
    RBracket        reduce using rule 52 (bit_and -> equality .)
    Colon           reduce using rule 52 (bit_and -> equality .)
    Identifier      reduce using rule 52 (bit_and -> equality .)
    Integer         reduce using rule 52 (bit_and -> equality .)
    LParen          reduce using rule 52 (bit_and -> equality .)
    Minus           reduce using rule 52 (bit_and -> equality .)
    BitNot          reduce using rule 52 (bit_and -> equality .)
    Not             reduce using rule 52 (bit_and -> equality .)
    NotEqual        shift and go to state 56
    Equal           shift and go to state 57


state 30

    (53) equality -> relational .
    (76) relational -> relational . Less additive
    (77) relational -> relational . Greater additive
    (78) relational -> relational . LessEqual additive
    (79) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 53 (equality -> relational .)
    Equal           reduce using rule 53 (equality -> relational .)
    BitAnd          reduce using rule 53 (equality -> relational .)
    Xor             reduce using rule 53 (equality -> relational .)
    BitOr           reduce using rule 53 (equality -> relational .)
    And             reduce using rule 53 (equality -> relational .)
    Question        reduce using rule 53 (equality -> relational .)
    Or              reduce using rule 53 (equality -> relational .)
    Semi            reduce using rule 53 (equality -> relational .)
    RParen          reduce using rule 53 (equality -> relational .)
    Comma           reduce using rule 53 (equality -> relational .)
    Int             reduce using rule 53 (equality -> relational .)
    RBracket        reduce using rule 53 (equality -> relational .)
    Colon           reduce using rule 53 (equality -> relational .)
    Identifier      reduce using rule 53 (equality -> relational .)
    Integer         reduce using rule 53 (equality -> relational .)
    LParen          reduce using rule 53 (equality -> relational .)
    Minus           reduce using rule 53 (equality -> relational .)
    BitNot          reduce using rule 53 (equality -> relational .)
    Not             reduce using rule 53 (equality -> relational .)
    Less            shift and go to state 58
    Greater         shift and go to state 59
    LessEqual       shift and go to state 60
    GreaterEqual    shift and go to state 61


state 31

    (54) relational -> additive .
    (80) additive -> additive . Plus multiplicative
    (81) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 54 (relational -> additive .)
    Greater         reduce using rule 54 (relational -> additive .)
    LessEqual       reduce using rule 54 (relational -> additive .)
    GreaterEqual    reduce using rule 54 (relational -> additive .)
    NotEqual        reduce using rule 54 (relational -> additive .)
    Equal           reduce using rule 54 (relational -> additive .)
    BitAnd          reduce using rule 54 (relational -> additive .)
    Xor             reduce using rule 54 (relational -> additive .)
    BitOr           reduce using rule 54 (relational -> additive .)
    And             reduce using rule 54 (relational -> additive .)
    Question        reduce using rule 54 (relational -> additive .)
    Or              reduce using rule 54 (relational -> additive .)
    Semi            reduce using rule 54 (relational -> additive .)
    RParen          reduce using rule 54 (relational -> additive .)
    Comma           reduce using rule 54 (relational -> additive .)
    Int             reduce using rule 54 (relational -> additive .)
    RBracket        reduce using rule 54 (relational -> additive .)
    Colon           reduce using rule 54 (relational -> additive .)
    Identifier      reduce using rule 54 (relational -> additive .)
    Integer         reduce using rule 54 (relational -> additive .)
    LParen          reduce using rule 54 (relational -> additive .)
    BitNot          reduce using rule 54 (relational -> additive .)
    Not             reduce using rule 54 (relational -> additive .)
    Plus            shift and go to state 62
    Minus           shift and go to state 63

  ! Minus           [ reduce using rule 54 (relational -> additive .) ]


state 32

    (55) additive -> multiplicative .
    (82) multiplicative -> multiplicative . Mul unary
    (83) multiplicative -> multiplicative . Div unary
    (84) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 55 (additive -> multiplicative .)
    Minus           reduce using rule 55 (additive -> multiplicative .)
    Less            reduce using rule 55 (additive -> multiplicative .)
    Greater         reduce using rule 55 (additive -> multiplicative .)
    LessEqual       reduce using rule 55 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 55 (additive -> multiplicative .)
    NotEqual        reduce using rule 55 (additive -> multiplicative .)
    Equal           reduce using rule 55 (additive -> multiplicative .)
    BitAnd          reduce using rule 55 (additive -> multiplicative .)
    Xor             reduce using rule 55 (additive -> multiplicative .)
    BitOr           reduce using rule 55 (additive -> multiplicative .)
    And             reduce using rule 55 (additive -> multiplicative .)
    Question        reduce using rule 55 (additive -> multiplicative .)
    Or              reduce using rule 55 (additive -> multiplicative .)
    Semi            reduce using rule 55 (additive -> multiplicative .)
    RParen          reduce using rule 55 (additive -> multiplicative .)
    Comma           reduce using rule 55 (additive -> multiplicative .)
    Int             reduce using rule 55 (additive -> multiplicative .)
    RBracket        reduce using rule 55 (additive -> multiplicative .)
    Colon           reduce using rule 55 (additive -> multiplicative .)
    Identifier      reduce using rule 55 (additive -> multiplicative .)
    Integer         reduce using rule 55 (additive -> multiplicative .)
    LParen          reduce using rule 55 (additive -> multiplicative .)
    BitNot          reduce using rule 55 (additive -> multiplicative .)
    Not             reduce using rule 55 (additive -> multiplicative .)
    Mul             shift and go to state 64
    Div             shift and go to state 65
    Mod             shift and go to state 66


state 33

    (65) unary -> Minus . unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    unary                          shift and go to state 67
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 34

    (56) multiplicative -> unary .

    Mul             reduce using rule 56 (multiplicative -> unary .)
    Div             reduce using rule 56 (multiplicative -> unary .)
    Mod             reduce using rule 56 (multiplicative -> unary .)
    Plus            reduce using rule 56 (multiplicative -> unary .)
    Minus           reduce using rule 56 (multiplicative -> unary .)
    Less            reduce using rule 56 (multiplicative -> unary .)
    Greater         reduce using rule 56 (multiplicative -> unary .)
    LessEqual       reduce using rule 56 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 56 (multiplicative -> unary .)
    NotEqual        reduce using rule 56 (multiplicative -> unary .)
    Equal           reduce using rule 56 (multiplicative -> unary .)
    BitAnd          reduce using rule 56 (multiplicative -> unary .)
    Xor             reduce using rule 56 (multiplicative -> unary .)
    BitOr           reduce using rule 56 (multiplicative -> unary .)
    And             reduce using rule 56 (multiplicative -> unary .)
    Question        reduce using rule 56 (multiplicative -> unary .)
    Or              reduce using rule 56 (multiplicative -> unary .)
    Semi            reduce using rule 56 (multiplicative -> unary .)
    RParen          reduce using rule 56 (multiplicative -> unary .)
    Comma           reduce using rule 56 (multiplicative -> unary .)
    Int             reduce using rule 56 (multiplicative -> unary .)
    RBracket        reduce using rule 56 (multiplicative -> unary .)
    Colon           reduce using rule 56 (multiplicative -> unary .)
    Identifier      reduce using rule 56 (multiplicative -> unary .)
    Integer         reduce using rule 56 (multiplicative -> unary .)
    LParen          reduce using rule 56 (multiplicative -> unary .)
    BitNot          reduce using rule 56 (multiplicative -> unary .)
    Not             reduce using rule 56 (multiplicative -> unary .)


state 35

    (66) unary -> BitNot . unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    unary                          shift and go to state 69
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 36

    (67) unary -> Not . unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    unary                          shift and go to state 70
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 37

    (41) declaration -> type Identifier dim_list Assign . init_list
    (42) init_list -> . LBrace init_elem RBrace

    LBrace          shift and go to state 72

    init_list                      shift and go to state 71

state 38

    (40) dim_list -> dim_list LBracket . Integer RBracket

    Integer         shift and go to state 73


state 39

    (38) dim_list -> LBracket RBracket .

    Assign          reduce using rule 38 (dim_list -> LBracket RBracket .)
    LBracket        reduce using rule 38 (dim_list -> LBracket RBracket .)
    Semi            reduce using rule 38 (dim_list -> LBracket RBracket .)
    RParen          reduce using rule 38 (dim_list -> LBracket RBracket .)
    Comma           reduce using rule 38 (dim_list -> LBracket RBracket .)
    Int             reduce using rule 38 (dim_list -> LBracket RBracket .)


state 40

    (39) dim_list -> LBracket Integer . RBracket

    RBracket        shift and go to state 74


state 41

    (12) params -> type . Identifier dim_list
    (35) declaration -> type . Identifier
    (36) declaration -> type . Identifier Assign expression
    (37) declaration -> type . Identifier dim_list
    (41) declaration -> type . Identifier dim_list Assign init_list

    Identifier      shift and go to state 75


state 42

    (7) function -> type Identifier LParen parameter RParen . LBrace block RBrace

    LBrace          shift and go to state 76


state 43

    (8) parameter -> parameter params .

    RParen          reduce using rule 8 (parameter -> parameter params .)
    Comma           reduce using rule 8 (parameter -> parameter params .)
    Int             reduce using rule 8 (parameter -> parameter params .)


state 44

    (10) params -> Comma . declaration
    (35) declaration -> . type Identifier
    (36) declaration -> . type Identifier Assign expression
    (37) declaration -> . type Identifier dim_list
    (41) declaration -> . type Identifier dim_list Assign init_list
    (6) type -> . Int

    Int             shift and go to state 7

    declaration                    shift and go to state 77
    type                           shift and go to state 78

state 45

    (11) params -> declaration .

    RParen          reduce using rule 11 (params -> declaration .)
    Comma           reduce using rule 11 (params -> declaration .)
    Int             reduce using rule 11 (params -> declaration .)


state 46

    (63) postfix -> Identifier LParen . expression_list RParen
    (59) expression_list -> . expression_list exprs
    (60) expression_list -> . empty
    (1) empty -> .

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)

    expression_list                shift and go to state 79
    empty                          shift and go to state 80

state 47

    (68) assignment -> postfix Assign . expression
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    postfix                        shift and go to state 20
    expression                     shift and go to state 81
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 48

    (64) postfix -> postfix LBracket . expression RBracket
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    postfix                        shift and go to state 20
    expression                     shift and go to state 82
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 49

    (85) conditional -> logical_or Question . expression Colon conditional
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    logical_or                     shift and go to state 21
    expression                     shift and go to state 83
    conditional                    shift and go to state 19
    assignment                     shift and go to state 18
    postfix                        shift and go to state 20
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 50

    (69) logical_or -> logical_or Or . logical_and
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    logical_and                    shift and go to state 84
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 51

    (88) primary -> LParen expression . RParen

    RParen          shift and go to state 85


state 52

    (70) logical_and -> logical_and And . bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    bit_or                         shift and go to state 86
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 53

    (71) bit_or -> bit_or BitOr . xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    xor                            shift and go to state 87
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 54

    (72) xor -> xor Xor . bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    bit_and                        shift and go to state 88
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 55

    (73) bit_and -> bit_and BitAnd . equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    equality                       shift and go to state 89
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 56

    (74) equality -> equality NotEqual . relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    relational                     shift and go to state 90
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 57

    (75) equality -> equality Equal . relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    relational                     shift and go to state 91
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 58

    (76) relational -> relational Less . additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    additive                       shift and go to state 92
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 59

    (77) relational -> relational Greater . additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    additive                       shift and go to state 93
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 60

    (78) relational -> relational LessEqual . additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    additive                       shift and go to state 94
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 61

    (79) relational -> relational GreaterEqual . additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    additive                       shift and go to state 95
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 62

    (80) additive -> additive Plus . multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    multiplicative                 shift and go to state 96
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 63

    (81) additive -> additive Minus . multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    multiplicative                 shift and go to state 97
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 64

    (82) multiplicative -> multiplicative Mul . unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    unary                          shift and go to state 98
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 65

    (83) multiplicative -> multiplicative Div . unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    unary                          shift and go to state 99
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 66

    (84) multiplicative -> multiplicative Mod . unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    unary                          shift and go to state 100
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 67

    (65) unary -> Minus unary .

    Mul             reduce using rule 65 (unary -> Minus unary .)
    Div             reduce using rule 65 (unary -> Minus unary .)
    Mod             reduce using rule 65 (unary -> Minus unary .)
    Plus            reduce using rule 65 (unary -> Minus unary .)
    Minus           reduce using rule 65 (unary -> Minus unary .)
    Less            reduce using rule 65 (unary -> Minus unary .)
    Greater         reduce using rule 65 (unary -> Minus unary .)
    LessEqual       reduce using rule 65 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 65 (unary -> Minus unary .)
    NotEqual        reduce using rule 65 (unary -> Minus unary .)
    Equal           reduce using rule 65 (unary -> Minus unary .)
    BitAnd          reduce using rule 65 (unary -> Minus unary .)
    Xor             reduce using rule 65 (unary -> Minus unary .)
    BitOr           reduce using rule 65 (unary -> Minus unary .)
    And             reduce using rule 65 (unary -> Minus unary .)
    Question        reduce using rule 65 (unary -> Minus unary .)
    Or              reduce using rule 65 (unary -> Minus unary .)
    Semi            reduce using rule 65 (unary -> Minus unary .)
    RParen          reduce using rule 65 (unary -> Minus unary .)
    Comma           reduce using rule 65 (unary -> Minus unary .)
    Int             reduce using rule 65 (unary -> Minus unary .)
    RBracket        reduce using rule 65 (unary -> Minus unary .)
    Colon           reduce using rule 65 (unary -> Minus unary .)
    Identifier      reduce using rule 65 (unary -> Minus unary .)
    Integer         reduce using rule 65 (unary -> Minus unary .)
    LParen          reduce using rule 65 (unary -> Minus unary .)
    BitNot          reduce using rule 65 (unary -> Minus unary .)
    Not             reduce using rule 65 (unary -> Minus unary .)


state 68

    (57) unary -> postfix .
    (64) postfix -> postfix . LBracket expression RBracket

    Mul             reduce using rule 57 (unary -> postfix .)
    Div             reduce using rule 57 (unary -> postfix .)
    Mod             reduce using rule 57 (unary -> postfix .)
    Plus            reduce using rule 57 (unary -> postfix .)
    Minus           reduce using rule 57 (unary -> postfix .)
    Less            reduce using rule 57 (unary -> postfix .)
    Greater         reduce using rule 57 (unary -> postfix .)
    LessEqual       reduce using rule 57 (unary -> postfix .)
    GreaterEqual    reduce using rule 57 (unary -> postfix .)
    NotEqual        reduce using rule 57 (unary -> postfix .)
    Equal           reduce using rule 57 (unary -> postfix .)
    BitAnd          reduce using rule 57 (unary -> postfix .)
    Xor             reduce using rule 57 (unary -> postfix .)
    BitOr           reduce using rule 57 (unary -> postfix .)
    And             reduce using rule 57 (unary -> postfix .)
    Question        reduce using rule 57 (unary -> postfix .)
    Or              reduce using rule 57 (unary -> postfix .)
    Semi            reduce using rule 57 (unary -> postfix .)
    RParen          reduce using rule 57 (unary -> postfix .)
    Comma           reduce using rule 57 (unary -> postfix .)
    Int             reduce using rule 57 (unary -> postfix .)
    RBracket        reduce using rule 57 (unary -> postfix .)
    Colon           reduce using rule 57 (unary -> postfix .)
    Identifier      reduce using rule 57 (unary -> postfix .)
    Integer         reduce using rule 57 (unary -> postfix .)
    LParen          reduce using rule 57 (unary -> postfix .)
    BitNot          reduce using rule 57 (unary -> postfix .)
    Not             reduce using rule 57 (unary -> postfix .)
    LBracket        shift and go to state 48


state 69

    (66) unary -> BitNot unary .

    Mul             reduce using rule 66 (unary -> BitNot unary .)
    Div             reduce using rule 66 (unary -> BitNot unary .)
    Mod             reduce using rule 66 (unary -> BitNot unary .)
    Plus            reduce using rule 66 (unary -> BitNot unary .)
    Minus           reduce using rule 66 (unary -> BitNot unary .)
    Less            reduce using rule 66 (unary -> BitNot unary .)
    Greater         reduce using rule 66 (unary -> BitNot unary .)
    LessEqual       reduce using rule 66 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 66 (unary -> BitNot unary .)
    NotEqual        reduce using rule 66 (unary -> BitNot unary .)
    Equal           reduce using rule 66 (unary -> BitNot unary .)
    BitAnd          reduce using rule 66 (unary -> BitNot unary .)
    Xor             reduce using rule 66 (unary -> BitNot unary .)
    BitOr           reduce using rule 66 (unary -> BitNot unary .)
    And             reduce using rule 66 (unary -> BitNot unary .)
    Question        reduce using rule 66 (unary -> BitNot unary .)
    Or              reduce using rule 66 (unary -> BitNot unary .)
    Semi            reduce using rule 66 (unary -> BitNot unary .)
    RParen          reduce using rule 66 (unary -> BitNot unary .)
    Comma           reduce using rule 66 (unary -> BitNot unary .)
    Int             reduce using rule 66 (unary -> BitNot unary .)
    RBracket        reduce using rule 66 (unary -> BitNot unary .)
    Colon           reduce using rule 66 (unary -> BitNot unary .)
    Identifier      reduce using rule 66 (unary -> BitNot unary .)
    Integer         reduce using rule 66 (unary -> BitNot unary .)
    LParen          reduce using rule 66 (unary -> BitNot unary .)
    BitNot          reduce using rule 66 (unary -> BitNot unary .)
    Not             reduce using rule 66 (unary -> BitNot unary .)


state 70

    (67) unary -> Not unary .

    Mul             reduce using rule 67 (unary -> Not unary .)
    Div             reduce using rule 67 (unary -> Not unary .)
    Mod             reduce using rule 67 (unary -> Not unary .)
    Plus            reduce using rule 67 (unary -> Not unary .)
    Minus           reduce using rule 67 (unary -> Not unary .)
    Less            reduce using rule 67 (unary -> Not unary .)
    Greater         reduce using rule 67 (unary -> Not unary .)
    LessEqual       reduce using rule 67 (unary -> Not unary .)
    GreaterEqual    reduce using rule 67 (unary -> Not unary .)
    NotEqual        reduce using rule 67 (unary -> Not unary .)
    Equal           reduce using rule 67 (unary -> Not unary .)
    BitAnd          reduce using rule 67 (unary -> Not unary .)
    Xor             reduce using rule 67 (unary -> Not unary .)
    BitOr           reduce using rule 67 (unary -> Not unary .)
    And             reduce using rule 67 (unary -> Not unary .)
    Question        reduce using rule 67 (unary -> Not unary .)
    Or              reduce using rule 67 (unary -> Not unary .)
    Semi            reduce using rule 67 (unary -> Not unary .)
    RParen          reduce using rule 67 (unary -> Not unary .)
    Comma           reduce using rule 67 (unary -> Not unary .)
    Int             reduce using rule 67 (unary -> Not unary .)
    RBracket        reduce using rule 67 (unary -> Not unary .)
    Colon           reduce using rule 67 (unary -> Not unary .)
    Identifier      reduce using rule 67 (unary -> Not unary .)
    Integer         reduce using rule 67 (unary -> Not unary .)
    LParen          reduce using rule 67 (unary -> Not unary .)
    BitNot          reduce using rule 67 (unary -> Not unary .)
    Not             reduce using rule 67 (unary -> Not unary .)


state 71

    (41) declaration -> type Identifier dim_list Assign init_list .

    Semi            reduce using rule 41 (declaration -> type Identifier dim_list Assign init_list .)
    RParen          reduce using rule 41 (declaration -> type Identifier dim_list Assign init_list .)
    Comma           reduce using rule 41 (declaration -> type Identifier dim_list Assign init_list .)
    Int             reduce using rule 41 (declaration -> type Identifier dim_list Assign init_list .)


state 72

    (42) init_list -> LBrace . init_elem RBrace
    (43) init_elem -> . Integer
    (44) init_elem -> . init_elem Comma Integer

    Integer         shift and go to state 102

    init_elem                      shift and go to state 101

state 73

    (40) dim_list -> dim_list LBracket Integer . RBracket

    RBracket        shift and go to state 103


state 74

    (39) dim_list -> LBracket Integer RBracket .

    Assign          reduce using rule 39 (dim_list -> LBracket Integer RBracket .)
    LBracket        reduce using rule 39 (dim_list -> LBracket Integer RBracket .)
    Semi            reduce using rule 39 (dim_list -> LBracket Integer RBracket .)
    RParen          reduce using rule 39 (dim_list -> LBracket Integer RBracket .)
    Comma           reduce using rule 39 (dim_list -> LBracket Integer RBracket .)
    Int             reduce using rule 39 (dim_list -> LBracket Integer RBracket .)


state 75

    (12) params -> type Identifier . dim_list
    (35) declaration -> type Identifier .
    (36) declaration -> type Identifier . Assign expression
    (37) declaration -> type Identifier . dim_list
    (41) declaration -> type Identifier . dim_list Assign init_list
    (38) dim_list -> . LBracket RBracket
    (39) dim_list -> . LBracket Integer RBracket
    (40) dim_list -> . dim_list LBracket Integer RBracket

    RParen          reduce using rule 35 (declaration -> type Identifier .)
    Comma           reduce using rule 35 (declaration -> type Identifier .)
    Int             reduce using rule 35 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 13

    dim_list                       shift and go to state 104

state 76

    (7) function -> type Identifier LParen parameter RParen LBrace . block RBrace
    (13) block -> . block block_item
    (14) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 105
    empty                          shift and go to state 106

state 77

    (10) params -> Comma declaration .

    RParen          reduce using rule 10 (params -> Comma declaration .)
    Comma           reduce using rule 10 (params -> Comma declaration .)
    Int             reduce using rule 10 (params -> Comma declaration .)


state 78

    (35) declaration -> type . Identifier
    (36) declaration -> type . Identifier Assign expression
    (37) declaration -> type . Identifier dim_list
    (41) declaration -> type . Identifier dim_list Assign init_list

    Identifier      shift and go to state 107


state 79

    (63) postfix -> Identifier LParen expression_list . RParen
    (59) expression_list -> expression_list . exprs
    (61) exprs -> . Comma expression
    (62) exprs -> . expression
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    RParen          shift and go to state 108
    Comma           shift and go to state 110
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    exprs                          shift and go to state 109
    expression                     shift and go to state 111
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 80

    (60) expression_list -> empty .

    RParen          reduce using rule 60 (expression_list -> empty .)
    Comma           reduce using rule 60 (expression_list -> empty .)
    Identifier      reduce using rule 60 (expression_list -> empty .)
    Integer         reduce using rule 60 (expression_list -> empty .)
    LParen          reduce using rule 60 (expression_list -> empty .)
    Minus           reduce using rule 60 (expression_list -> empty .)
    BitNot          reduce using rule 60 (expression_list -> empty .)
    Not             reduce using rule 60 (expression_list -> empty .)


state 81

    (68) assignment -> postfix Assign expression .

    Semi            reduce using rule 68 (assignment -> postfix Assign expression .)
    RParen          reduce using rule 68 (assignment -> postfix Assign expression .)
    Comma           reduce using rule 68 (assignment -> postfix Assign expression .)
    Int             reduce using rule 68 (assignment -> postfix Assign expression .)
    RBracket        reduce using rule 68 (assignment -> postfix Assign expression .)
    Colon           reduce using rule 68 (assignment -> postfix Assign expression .)
    Identifier      reduce using rule 68 (assignment -> postfix Assign expression .)
    Integer         reduce using rule 68 (assignment -> postfix Assign expression .)
    LParen          reduce using rule 68 (assignment -> postfix Assign expression .)
    Minus           reduce using rule 68 (assignment -> postfix Assign expression .)
    BitNot          reduce using rule 68 (assignment -> postfix Assign expression .)
    Not             reduce using rule 68 (assignment -> postfix Assign expression .)


state 82

    (64) postfix -> postfix LBracket expression . RBracket

    RBracket        shift and go to state 112


state 83

    (85) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 113


state 84

    (69) logical_or -> logical_or Or logical_and .
    (70) logical_and -> logical_and . And bit_or

    Question        reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Int             reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    RBracket        reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Identifier      reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Integer         reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    LParen          reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Minus           reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    BitNot          reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    Not             reduce using rule 69 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 52


state 85

    (88) primary -> LParen expression RParen .

    Assign          reduce using rule 88 (primary -> LParen expression RParen .)
    LBracket        reduce using rule 88 (primary -> LParen expression RParen .)
    Mul             reduce using rule 88 (primary -> LParen expression RParen .)
    Div             reduce using rule 88 (primary -> LParen expression RParen .)
    Mod             reduce using rule 88 (primary -> LParen expression RParen .)
    Plus            reduce using rule 88 (primary -> LParen expression RParen .)
    Minus           reduce using rule 88 (primary -> LParen expression RParen .)
    Less            reduce using rule 88 (primary -> LParen expression RParen .)
    Greater         reduce using rule 88 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 88 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 88 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 88 (primary -> LParen expression RParen .)
    Equal           reduce using rule 88 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 88 (primary -> LParen expression RParen .)
    Xor             reduce using rule 88 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 88 (primary -> LParen expression RParen .)
    And             reduce using rule 88 (primary -> LParen expression RParen .)
    Question        reduce using rule 88 (primary -> LParen expression RParen .)
    Or              reduce using rule 88 (primary -> LParen expression RParen .)
    Semi            reduce using rule 88 (primary -> LParen expression RParen .)
    RParen          reduce using rule 88 (primary -> LParen expression RParen .)
    Comma           reduce using rule 88 (primary -> LParen expression RParen .)
    Int             reduce using rule 88 (primary -> LParen expression RParen .)
    RBracket        reduce using rule 88 (primary -> LParen expression RParen .)
    Colon           reduce using rule 88 (primary -> LParen expression RParen .)
    Identifier      reduce using rule 88 (primary -> LParen expression RParen .)
    Integer         reduce using rule 88 (primary -> LParen expression RParen .)
    LParen          reduce using rule 88 (primary -> LParen expression RParen .)
    BitNot          reduce using rule 88 (primary -> LParen expression RParen .)
    Not             reduce using rule 88 (primary -> LParen expression RParen .)


state 86

    (70) logical_and -> logical_and And bit_or .
    (71) bit_or -> bit_or . BitOr xor

    And             reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 70 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Int             reduce using rule 70 (logical_and -> logical_and And bit_or .)
    RBracket        reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Identifier      reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Integer         reduce using rule 70 (logical_and -> logical_and And bit_or .)
    LParen          reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Minus           reduce using rule 70 (logical_and -> logical_and And bit_or .)
    BitNot          reduce using rule 70 (logical_and -> logical_and And bit_or .)
    Not             reduce using rule 70 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 53


state 87

    (71) bit_or -> bit_or BitOr xor .
    (72) xor -> xor . Xor bit_and

    BitOr           reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Int             reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    RBracket        reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Identifier      reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Integer         reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    LParen          reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Minus           reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    BitNot          reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Not             reduce using rule 71 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 54


state 88

    (72) xor -> xor Xor bit_and .
    (73) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 72 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 72 (xor -> xor Xor bit_and .)
    And             reduce using rule 72 (xor -> xor Xor bit_and .)
    Question        reduce using rule 72 (xor -> xor Xor bit_and .)
    Or              reduce using rule 72 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 72 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 72 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 72 (xor -> xor Xor bit_and .)
    Int             reduce using rule 72 (xor -> xor Xor bit_and .)
    RBracket        reduce using rule 72 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 72 (xor -> xor Xor bit_and .)
    Identifier      reduce using rule 72 (xor -> xor Xor bit_and .)
    Integer         reduce using rule 72 (xor -> xor Xor bit_and .)
    LParen          reduce using rule 72 (xor -> xor Xor bit_and .)
    Minus           reduce using rule 72 (xor -> xor Xor bit_and .)
    BitNot          reduce using rule 72 (xor -> xor Xor bit_and .)
    Not             reduce using rule 72 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 55


state 89

    (73) bit_and -> bit_and BitAnd equality .
    (74) equality -> equality . NotEqual relational
    (75) equality -> equality . Equal relational

    BitAnd          reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Int             reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    RBracket        reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Identifier      reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Integer         reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    LParen          reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Minus           reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    BitNot          reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    Not             reduce using rule 73 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 56
    Equal           shift and go to state 57


state 90

    (74) equality -> equality NotEqual relational .
    (76) relational -> relational . Less additive
    (77) relational -> relational . Greater additive
    (78) relational -> relational . LessEqual additive
    (79) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 74 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 74 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 74 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 74 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 74 (equality -> equality NotEqual relational .)
    And             reduce using rule 74 (equality -> equality NotEqual relational .)
    Question        reduce using rule 74 (equality -> equality NotEqual relational .)
    Or              reduce using rule 74 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 74 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 74 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 74 (equality -> equality NotEqual relational .)
    Int             reduce using rule 74 (equality -> equality NotEqual relational .)
    RBracket        reduce using rule 74 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 74 (equality -> equality NotEqual relational .)
    Identifier      reduce using rule 74 (equality -> equality NotEqual relational .)
    Integer         reduce using rule 74 (equality -> equality NotEqual relational .)
    LParen          reduce using rule 74 (equality -> equality NotEqual relational .)
    Minus           reduce using rule 74 (equality -> equality NotEqual relational .)
    BitNot          reduce using rule 74 (equality -> equality NotEqual relational .)
    Not             reduce using rule 74 (equality -> equality NotEqual relational .)
    Less            shift and go to state 58
    Greater         shift and go to state 59
    LessEqual       shift and go to state 60
    GreaterEqual    shift and go to state 61


state 91

    (75) equality -> equality Equal relational .
    (76) relational -> relational . Less additive
    (77) relational -> relational . Greater additive
    (78) relational -> relational . LessEqual additive
    (79) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 75 (equality -> equality Equal relational .)
    Equal           reduce using rule 75 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 75 (equality -> equality Equal relational .)
    Xor             reduce using rule 75 (equality -> equality Equal relational .)
    BitOr           reduce using rule 75 (equality -> equality Equal relational .)
    And             reduce using rule 75 (equality -> equality Equal relational .)
    Question        reduce using rule 75 (equality -> equality Equal relational .)
    Or              reduce using rule 75 (equality -> equality Equal relational .)
    Semi            reduce using rule 75 (equality -> equality Equal relational .)
    RParen          reduce using rule 75 (equality -> equality Equal relational .)
    Comma           reduce using rule 75 (equality -> equality Equal relational .)
    Int             reduce using rule 75 (equality -> equality Equal relational .)
    RBracket        reduce using rule 75 (equality -> equality Equal relational .)
    Colon           reduce using rule 75 (equality -> equality Equal relational .)
    Identifier      reduce using rule 75 (equality -> equality Equal relational .)
    Integer         reduce using rule 75 (equality -> equality Equal relational .)
    LParen          reduce using rule 75 (equality -> equality Equal relational .)
    Minus           reduce using rule 75 (equality -> equality Equal relational .)
    BitNot          reduce using rule 75 (equality -> equality Equal relational .)
    Not             reduce using rule 75 (equality -> equality Equal relational .)
    Less            shift and go to state 58
    Greater         shift and go to state 59
    LessEqual       shift and go to state 60
    GreaterEqual    shift and go to state 61


state 92

    (76) relational -> relational Less additive .
    (80) additive -> additive . Plus multiplicative
    (81) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 76 (relational -> relational Less additive .)
    Greater         reduce using rule 76 (relational -> relational Less additive .)
    LessEqual       reduce using rule 76 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 76 (relational -> relational Less additive .)
    NotEqual        reduce using rule 76 (relational -> relational Less additive .)
    Equal           reduce using rule 76 (relational -> relational Less additive .)
    BitAnd          reduce using rule 76 (relational -> relational Less additive .)
    Xor             reduce using rule 76 (relational -> relational Less additive .)
    BitOr           reduce using rule 76 (relational -> relational Less additive .)
    And             reduce using rule 76 (relational -> relational Less additive .)
    Question        reduce using rule 76 (relational -> relational Less additive .)
    Or              reduce using rule 76 (relational -> relational Less additive .)
    Semi            reduce using rule 76 (relational -> relational Less additive .)
    RParen          reduce using rule 76 (relational -> relational Less additive .)
    Comma           reduce using rule 76 (relational -> relational Less additive .)
    Int             reduce using rule 76 (relational -> relational Less additive .)
    RBracket        reduce using rule 76 (relational -> relational Less additive .)
    Colon           reduce using rule 76 (relational -> relational Less additive .)
    Identifier      reduce using rule 76 (relational -> relational Less additive .)
    Integer         reduce using rule 76 (relational -> relational Less additive .)
    LParen          reduce using rule 76 (relational -> relational Less additive .)
    BitNot          reduce using rule 76 (relational -> relational Less additive .)
    Not             reduce using rule 76 (relational -> relational Less additive .)
    Plus            shift and go to state 62
    Minus           shift and go to state 63

  ! Minus           [ reduce using rule 76 (relational -> relational Less additive .) ]


state 93

    (77) relational -> relational Greater additive .
    (80) additive -> additive . Plus multiplicative
    (81) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 77 (relational -> relational Greater additive .)
    Greater         reduce using rule 77 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 77 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 77 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 77 (relational -> relational Greater additive .)
    Equal           reduce using rule 77 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 77 (relational -> relational Greater additive .)
    Xor             reduce using rule 77 (relational -> relational Greater additive .)
    BitOr           reduce using rule 77 (relational -> relational Greater additive .)
    And             reduce using rule 77 (relational -> relational Greater additive .)
    Question        reduce using rule 77 (relational -> relational Greater additive .)
    Or              reduce using rule 77 (relational -> relational Greater additive .)
    Semi            reduce using rule 77 (relational -> relational Greater additive .)
    RParen          reduce using rule 77 (relational -> relational Greater additive .)
    Comma           reduce using rule 77 (relational -> relational Greater additive .)
    Int             reduce using rule 77 (relational -> relational Greater additive .)
    RBracket        reduce using rule 77 (relational -> relational Greater additive .)
    Colon           reduce using rule 77 (relational -> relational Greater additive .)
    Identifier      reduce using rule 77 (relational -> relational Greater additive .)
    Integer         reduce using rule 77 (relational -> relational Greater additive .)
    LParen          reduce using rule 77 (relational -> relational Greater additive .)
    BitNot          reduce using rule 77 (relational -> relational Greater additive .)
    Not             reduce using rule 77 (relational -> relational Greater additive .)
    Plus            shift and go to state 62
    Minus           shift and go to state 63

  ! Minus           [ reduce using rule 77 (relational -> relational Greater additive .) ]


state 94

    (78) relational -> relational LessEqual additive .
    (80) additive -> additive . Plus multiplicative
    (81) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 78 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 78 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 78 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 78 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 78 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 78 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 78 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 78 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 78 (relational -> relational LessEqual additive .)
    And             reduce using rule 78 (relational -> relational LessEqual additive .)
    Question        reduce using rule 78 (relational -> relational LessEqual additive .)
    Or              reduce using rule 78 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 78 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 78 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 78 (relational -> relational LessEqual additive .)
    Int             reduce using rule 78 (relational -> relational LessEqual additive .)
    RBracket        reduce using rule 78 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 78 (relational -> relational LessEqual additive .)
    Identifier      reduce using rule 78 (relational -> relational LessEqual additive .)
    Integer         reduce using rule 78 (relational -> relational LessEqual additive .)
    LParen          reduce using rule 78 (relational -> relational LessEqual additive .)
    BitNot          reduce using rule 78 (relational -> relational LessEqual additive .)
    Not             reduce using rule 78 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 62
    Minus           shift and go to state 63

  ! Minus           [ reduce using rule 78 (relational -> relational LessEqual additive .) ]


state 95

    (79) relational -> relational GreaterEqual additive .
    (80) additive -> additive . Plus multiplicative
    (81) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 79 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 79 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 79 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 79 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 79 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 79 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 79 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Int             reduce using rule 79 (relational -> relational GreaterEqual additive .)
    RBracket        reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Identifier      reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Integer         reduce using rule 79 (relational -> relational GreaterEqual additive .)
    LParen          reduce using rule 79 (relational -> relational GreaterEqual additive .)
    BitNot          reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Not             reduce using rule 79 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 62
    Minus           shift and go to state 63

  ! Minus           [ reduce using rule 79 (relational -> relational GreaterEqual additive .) ]


state 96

    (80) additive -> additive Plus multiplicative .
    (82) multiplicative -> multiplicative . Mul unary
    (83) multiplicative -> multiplicative . Div unary
    (84) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 80 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 80 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 80 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 80 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 80 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 80 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 80 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 80 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 80 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 80 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 80 (additive -> additive Plus multiplicative .)
    And             reduce using rule 80 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 80 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 80 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 80 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 80 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 80 (additive -> additive Plus multiplicative .)
    Int             reduce using rule 80 (additive -> additive Plus multiplicative .)
    RBracket        reduce using rule 80 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 80 (additive -> additive Plus multiplicative .)
    Identifier      reduce using rule 80 (additive -> additive Plus multiplicative .)
    Integer         reduce using rule 80 (additive -> additive Plus multiplicative .)
    LParen          reduce using rule 80 (additive -> additive Plus multiplicative .)
    BitNot          reduce using rule 80 (additive -> additive Plus multiplicative .)
    Not             reduce using rule 80 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 64
    Div             shift and go to state 65
    Mod             shift and go to state 66


state 97

    (81) additive -> additive Minus multiplicative .
    (82) multiplicative -> multiplicative . Mul unary
    (83) multiplicative -> multiplicative . Div unary
    (84) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 81 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 81 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 81 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 81 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 81 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 81 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 81 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 81 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 81 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 81 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 81 (additive -> additive Minus multiplicative .)
    And             reduce using rule 81 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 81 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 81 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 81 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 81 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 81 (additive -> additive Minus multiplicative .)
    Int             reduce using rule 81 (additive -> additive Minus multiplicative .)
    RBracket        reduce using rule 81 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 81 (additive -> additive Minus multiplicative .)
    Identifier      reduce using rule 81 (additive -> additive Minus multiplicative .)
    Integer         reduce using rule 81 (additive -> additive Minus multiplicative .)
    LParen          reduce using rule 81 (additive -> additive Minus multiplicative .)
    BitNot          reduce using rule 81 (additive -> additive Minus multiplicative .)
    Not             reduce using rule 81 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 64
    Div             shift and go to state 65
    Mod             shift and go to state 66


state 98

    (82) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Int             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    RBracket        reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Identifier      reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Integer         reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    LParen          reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    BitNot          reduce using rule 82 (multiplicative -> multiplicative Mul unary .)
    Not             reduce using rule 82 (multiplicative -> multiplicative Mul unary .)


state 99

    (83) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Int             reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    RBracket        reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Identifier      reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Integer         reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    LParen          reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    BitNot          reduce using rule 83 (multiplicative -> multiplicative Div unary .)
    Not             reduce using rule 83 (multiplicative -> multiplicative Div unary .)


state 100

    (84) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Int             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    RBracket        reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Identifier      reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Integer         reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    LParen          reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    BitNot          reduce using rule 84 (multiplicative -> multiplicative Mod unary .)
    Not             reduce using rule 84 (multiplicative -> multiplicative Mod unary .)


state 101

    (42) init_list -> LBrace init_elem . RBrace
    (44) init_elem -> init_elem . Comma Integer

    RBrace          shift and go to state 114
    Comma           shift and go to state 115


state 102

    (43) init_elem -> Integer .

    RBrace          reduce using rule 43 (init_elem -> Integer .)
    Comma           reduce using rule 43 (init_elem -> Integer .)


state 103

    (40) dim_list -> dim_list LBracket Integer RBracket .

    Assign          reduce using rule 40 (dim_list -> dim_list LBracket Integer RBracket .)
    LBracket        reduce using rule 40 (dim_list -> dim_list LBracket Integer RBracket .)
    Semi            reduce using rule 40 (dim_list -> dim_list LBracket Integer RBracket .)
    RParen          reduce using rule 40 (dim_list -> dim_list LBracket Integer RBracket .)
    Comma           reduce using rule 40 (dim_list -> dim_list LBracket Integer RBracket .)
    Int             reduce using rule 40 (dim_list -> dim_list LBracket Integer RBracket .)


state 104

    (12) params -> type Identifier dim_list .
    (37) declaration -> type Identifier dim_list .
    (41) declaration -> type Identifier dim_list . Assign init_list
    (40) dim_list -> dim_list . LBracket Integer RBracket

  ! reduce/reduce conflict for RParen resolved using rule 12 (params -> type Identifier dim_list .)
  ! reduce/reduce conflict for Comma resolved using rule 12 (params -> type Identifier dim_list .)
  ! reduce/reduce conflict for Int resolved using rule 12 (params -> type Identifier dim_list .)
    RParen          reduce using rule 12 (params -> type Identifier dim_list .)
    Comma           reduce using rule 12 (params -> type Identifier dim_list .)
    Int             reduce using rule 12 (params -> type Identifier dim_list .)
    Assign          shift and go to state 37
    LBracket        shift and go to state 38

  ! RParen          [ reduce using rule 37 (declaration -> type Identifier dim_list .) ]
  ! Comma           [ reduce using rule 37 (declaration -> type Identifier dim_list .) ]
  ! Int             [ reduce using rule 37 (declaration -> type Identifier dim_list .) ]


state 105

    (7) function -> type Identifier LParen parameter RParen LBrace block . RBrace
    (13) block -> block . block_item
    (15) block_item -> . statement
    (16) block_item -> . declaration Semi
    (17) statement -> . statement_matched
    (18) statement -> . statement_unmatched
    (35) declaration -> . type Identifier
    (36) declaration -> . type Identifier Assign expression
    (37) declaration -> . type Identifier dim_list
    (41) declaration -> . type Identifier dim_list Assign init_list
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (6) type -> . Int
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    RBrace          shift and go to state 117
    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    type                           shift and go to state 78
    block_item                     shift and go to state 118
    statement                      shift and go to state 119
    declaration                    shift and go to state 120
    statement_matched              shift and go to state 121
    statement_unmatched            shift and go to state 122
    expression                     shift and go to state 123
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 106

    (14) block -> empty .

    RBrace          reduce using rule 14 (block -> empty .)
    If              reduce using rule 14 (block -> empty .)
    While           reduce using rule 14 (block -> empty .)
    For             reduce using rule 14 (block -> empty .)
    Return          reduce using rule 14 (block -> empty .)
    LBrace          reduce using rule 14 (block -> empty .)
    Break           reduce using rule 14 (block -> empty .)
    Continue        reduce using rule 14 (block -> empty .)
    Int             reduce using rule 14 (block -> empty .)
    Identifier      reduce using rule 14 (block -> empty .)
    Integer         reduce using rule 14 (block -> empty .)
    LParen          reduce using rule 14 (block -> empty .)
    Minus           reduce using rule 14 (block -> empty .)
    BitNot          reduce using rule 14 (block -> empty .)
    Not             reduce using rule 14 (block -> empty .)
    Semi            reduce using rule 14 (block -> empty .)


state 107

    (35) declaration -> type Identifier .
    (36) declaration -> type Identifier . Assign expression
    (37) declaration -> type Identifier . dim_list
    (41) declaration -> type Identifier . dim_list Assign init_list
    (38) dim_list -> . LBracket RBracket
    (39) dim_list -> . LBracket Integer RBracket
    (40) dim_list -> . dim_list LBracket Integer RBracket

    RParen          reduce using rule 35 (declaration -> type Identifier .)
    Comma           reduce using rule 35 (declaration -> type Identifier .)
    Int             reduce using rule 35 (declaration -> type Identifier .)
    Semi            reduce using rule 35 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 13

    dim_list                       shift and go to state 12

state 108

    (63) postfix -> Identifier LParen expression_list RParen .

    Assign          reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    LBracket        reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Mul             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Int             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    RBracket        reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Identifier      reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Integer         reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    LParen          reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    BitNot          reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)
    Not             reduce using rule 63 (postfix -> Identifier LParen expression_list RParen .)


state 109

    (59) expression_list -> expression_list exprs .

    RParen          reduce using rule 59 (expression_list -> expression_list exprs .)
    Comma           reduce using rule 59 (expression_list -> expression_list exprs .)
    Identifier      reduce using rule 59 (expression_list -> expression_list exprs .)
    Integer         reduce using rule 59 (expression_list -> expression_list exprs .)
    LParen          reduce using rule 59 (expression_list -> expression_list exprs .)
    Minus           reduce using rule 59 (expression_list -> expression_list exprs .)
    BitNot          reduce using rule 59 (expression_list -> expression_list exprs .)
    Not             reduce using rule 59 (expression_list -> expression_list exprs .)


state 110

    (61) exprs -> Comma . expression
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 132
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 111

    (62) exprs -> expression .

    RParen          reduce using rule 62 (exprs -> expression .)
    Comma           reduce using rule 62 (exprs -> expression .)
    Identifier      reduce using rule 62 (exprs -> expression .)
    Integer         reduce using rule 62 (exprs -> expression .)
    LParen          reduce using rule 62 (exprs -> expression .)
    Minus           reduce using rule 62 (exprs -> expression .)
    BitNot          reduce using rule 62 (exprs -> expression .)
    Not             reduce using rule 62 (exprs -> expression .)


state 112

    (64) postfix -> postfix LBracket expression RBracket .

    Assign          reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    LBracket        reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Mul             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Div             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Mod             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Plus            reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Minus           reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Less            reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Greater         reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    LessEqual       reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    GreaterEqual    reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    NotEqual        reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Equal           reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    BitAnd          reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Xor             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    BitOr           reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    And             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Question        reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Or              reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Semi            reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    RParen          reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Comma           reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Int             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    RBracket        reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Colon           reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Identifier      reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Integer         reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    LParen          reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    BitNot          reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)
    Not             reduce using rule 64 (postfix -> postfix LBracket expression RBracket .)


state 113

    (85) conditional -> logical_or Question expression Colon . conditional
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen

    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23

    logical_or                     shift and go to state 21
    conditional                    shift and go to state 133
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34
    postfix                        shift and go to state 68
    primary                        shift and go to state 22

state 114

    (42) init_list -> LBrace init_elem RBrace .

    Semi            reduce using rule 42 (init_list -> LBrace init_elem RBrace .)
    RParen          reduce using rule 42 (init_list -> LBrace init_elem RBrace .)
    Comma           reduce using rule 42 (init_list -> LBrace init_elem RBrace .)
    Int             reduce using rule 42 (init_list -> LBrace init_elem RBrace .)


state 115

    (44) init_elem -> init_elem Comma . Integer

    Integer         shift and go to state 134


state 116

    (30) statement_matched -> LBrace . block RBrace
    (13) block -> . block block_item
    (14) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 135
    empty                          shift and go to state 106

state 117

    (7) function -> type Identifier LParen parameter RParen LBrace block RBrace .

    Int             reduce using rule 7 (function -> type Identifier LParen parameter RParen LBrace block RBrace .)
    $end            reduce using rule 7 (function -> type Identifier LParen parameter RParen LBrace block RBrace .)


state 118

    (13) block -> block block_item .

    RBrace          reduce using rule 13 (block -> block block_item .)
    If              reduce using rule 13 (block -> block block_item .)
    While           reduce using rule 13 (block -> block block_item .)
    For             reduce using rule 13 (block -> block block_item .)
    Return          reduce using rule 13 (block -> block block_item .)
    LBrace          reduce using rule 13 (block -> block block_item .)
    Break           reduce using rule 13 (block -> block block_item .)
    Continue        reduce using rule 13 (block -> block block_item .)
    Int             reduce using rule 13 (block -> block block_item .)
    Identifier      reduce using rule 13 (block -> block block_item .)
    Integer         reduce using rule 13 (block -> block block_item .)
    LParen          reduce using rule 13 (block -> block block_item .)
    Minus           reduce using rule 13 (block -> block block_item .)
    BitNot          reduce using rule 13 (block -> block block_item .)
    Not             reduce using rule 13 (block -> block block_item .)
    Semi            reduce using rule 13 (block -> block block_item .)


state 119

    (15) block_item -> statement .

    RBrace          reduce using rule 15 (block_item -> statement .)
    If              reduce using rule 15 (block_item -> statement .)
    While           reduce using rule 15 (block_item -> statement .)
    For             reduce using rule 15 (block_item -> statement .)
    Return          reduce using rule 15 (block_item -> statement .)
    LBrace          reduce using rule 15 (block_item -> statement .)
    Break           reduce using rule 15 (block_item -> statement .)
    Continue        reduce using rule 15 (block_item -> statement .)
    Int             reduce using rule 15 (block_item -> statement .)
    Identifier      reduce using rule 15 (block_item -> statement .)
    Integer         reduce using rule 15 (block_item -> statement .)
    LParen          reduce using rule 15 (block_item -> statement .)
    Minus           reduce using rule 15 (block_item -> statement .)
    BitNot          reduce using rule 15 (block_item -> statement .)
    Not             reduce using rule 15 (block_item -> statement .)
    Semi            reduce using rule 15 (block_item -> statement .)


state 120

    (16) block_item -> declaration . Semi

    Semi            shift and go to state 136


state 121

    (17) statement -> statement_matched .

    RBrace          reduce using rule 17 (statement -> statement_matched .)
    If              reduce using rule 17 (statement -> statement_matched .)
    While           reduce using rule 17 (statement -> statement_matched .)
    For             reduce using rule 17 (statement -> statement_matched .)
    Return          reduce using rule 17 (statement -> statement_matched .)
    LBrace          reduce using rule 17 (statement -> statement_matched .)
    Break           reduce using rule 17 (statement -> statement_matched .)
    Continue        reduce using rule 17 (statement -> statement_matched .)
    Int             reduce using rule 17 (statement -> statement_matched .)
    Identifier      reduce using rule 17 (statement -> statement_matched .)
    Integer         reduce using rule 17 (statement -> statement_matched .)
    LParen          reduce using rule 17 (statement -> statement_matched .)
    Minus           reduce using rule 17 (statement -> statement_matched .)
    BitNot          reduce using rule 17 (statement -> statement_matched .)
    Not             reduce using rule 17 (statement -> statement_matched .)
    Semi            reduce using rule 17 (statement -> statement_matched .)


state 122

    (18) statement -> statement_unmatched .

    RBrace          reduce using rule 18 (statement -> statement_unmatched .)
    If              reduce using rule 18 (statement -> statement_unmatched .)
    While           reduce using rule 18 (statement -> statement_unmatched .)
    For             reduce using rule 18 (statement -> statement_unmatched .)
    Return          reduce using rule 18 (statement -> statement_unmatched .)
    LBrace          reduce using rule 18 (statement -> statement_unmatched .)
    Break           reduce using rule 18 (statement -> statement_unmatched .)
    Continue        reduce using rule 18 (statement -> statement_unmatched .)
    Int             reduce using rule 18 (statement -> statement_unmatched .)
    Identifier      reduce using rule 18 (statement -> statement_unmatched .)
    Integer         reduce using rule 18 (statement -> statement_unmatched .)
    LParen          reduce using rule 18 (statement -> statement_unmatched .)
    Minus           reduce using rule 18 (statement -> statement_unmatched .)
    BitNot          reduce using rule 18 (statement -> statement_unmatched .)
    Not             reduce using rule 18 (statement -> statement_unmatched .)
    Semi            reduce using rule 18 (statement -> statement_unmatched .)


state 123

    (33) opt_expression -> expression .

    Semi            reduce using rule 33 (opt_expression -> expression .)


state 124

    (19) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (20) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 137


state 125

    (22) statement_matched -> While . LParen expression RParen statement_matched
    (23) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 138


state 126

    (24) statement_matched -> For . LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> For . LParen declaration Semi expression Semi expression RParen statement_matched
    (26) statement_unmatched -> For . LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> For . LParen declaration Semi expression Semi expression RParen statement_unmatched

    LParen          shift and go to state 139


state 127

    (28) statement_matched -> Return . expression Semi
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 140
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 128

    (29) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 141


state 129

    (31) statement_matched -> Break . Semi

    Semi            shift and go to state 142


state 130

    (32) statement_matched -> Continue . Semi

    Semi            shift and go to state 143


state 131

    (34) opt_expression -> empty .

    Semi            reduce using rule 34 (opt_expression -> empty .)


state 132

    (61) exprs -> Comma expression .

    RParen          reduce using rule 61 (exprs -> Comma expression .)
    Comma           reduce using rule 61 (exprs -> Comma expression .)
    Identifier      reduce using rule 61 (exprs -> Comma expression .)
    Integer         reduce using rule 61 (exprs -> Comma expression .)
    LParen          reduce using rule 61 (exprs -> Comma expression .)
    Minus           reduce using rule 61 (exprs -> Comma expression .)
    BitNot          reduce using rule 61 (exprs -> Comma expression .)
    Not             reduce using rule 61 (exprs -> Comma expression .)


state 133

    (85) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Int             reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    RBracket        reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Identifier      reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Integer         reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    LParen          reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Minus           reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    BitNot          reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)
    Not             reduce using rule 85 (conditional -> logical_or Question expression Colon conditional .)


state 134

    (44) init_elem -> init_elem Comma Integer .

    RBrace          reduce using rule 44 (init_elem -> init_elem Comma Integer .)
    Comma           reduce using rule 44 (init_elem -> init_elem Comma Integer .)


state 135

    (30) statement_matched -> LBrace block . RBrace
    (13) block -> block . block_item
    (15) block_item -> . statement
    (16) block_item -> . declaration Semi
    (17) statement -> . statement_matched
    (18) statement -> . statement_unmatched
    (35) declaration -> . type Identifier
    (36) declaration -> . type Identifier Assign expression
    (37) declaration -> . type Identifier dim_list
    (41) declaration -> . type Identifier dim_list Assign init_list
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (6) type -> . Int
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    RBrace          shift and go to state 144
    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    block_item                     shift and go to state 118
    statement                      shift and go to state 119
    declaration                    shift and go to state 120
    statement_matched              shift and go to state 121
    statement_unmatched            shift and go to state 122
    type                           shift and go to state 78
    expression                     shift and go to state 123
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 136

    (16) block_item -> declaration Semi .

    RBrace          reduce using rule 16 (block_item -> declaration Semi .)
    If              reduce using rule 16 (block_item -> declaration Semi .)
    While           reduce using rule 16 (block_item -> declaration Semi .)
    For             reduce using rule 16 (block_item -> declaration Semi .)
    Return          reduce using rule 16 (block_item -> declaration Semi .)
    LBrace          reduce using rule 16 (block_item -> declaration Semi .)
    Break           reduce using rule 16 (block_item -> declaration Semi .)
    Continue        reduce using rule 16 (block_item -> declaration Semi .)
    Int             reduce using rule 16 (block_item -> declaration Semi .)
    Identifier      reduce using rule 16 (block_item -> declaration Semi .)
    Integer         reduce using rule 16 (block_item -> declaration Semi .)
    LParen          reduce using rule 16 (block_item -> declaration Semi .)
    Minus           reduce using rule 16 (block_item -> declaration Semi .)
    BitNot          reduce using rule 16 (block_item -> declaration Semi .)
    Not             reduce using rule 16 (block_item -> declaration Semi .)
    Semi            reduce using rule 16 (block_item -> declaration Semi .)


state 137

    (19) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (20) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> If LParen . expression RParen statement
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 145
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 138

    (22) statement_matched -> While LParen . expression RParen statement_matched
    (23) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 146
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 139

    (24) statement_matched -> For LParen . expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> For LParen . declaration Semi expression Semi expression RParen statement_matched
    (26) statement_unmatched -> For LParen . expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> For LParen . declaration Semi expression Semi expression RParen statement_unmatched
    (45) expression -> . assignment
    (35) declaration -> . type Identifier
    (36) declaration -> . type Identifier Assign expression
    (37) declaration -> . type Identifier dim_list
    (41) declaration -> . type Identifier dim_list Assign init_list
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (6) type -> . Int
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Int             shift and go to state 7
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 147
    declaration                    shift and go to state 148
    assignment                     shift and go to state 18
    type                           shift and go to state 78
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 140

    (28) statement_matched -> Return expression . Semi

    Semi            shift and go to state 149


state 141

    (29) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 29 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 29 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 29 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 29 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 29 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 29 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 29 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 29 (statement_matched -> opt_expression Semi .)


state 142

    (31) statement_matched -> Break Semi .

    RBrace          reduce using rule 31 (statement_matched -> Break Semi .)
    If              reduce using rule 31 (statement_matched -> Break Semi .)
    While           reduce using rule 31 (statement_matched -> Break Semi .)
    For             reduce using rule 31 (statement_matched -> Break Semi .)
    Return          reduce using rule 31 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 31 (statement_matched -> Break Semi .)
    Break           reduce using rule 31 (statement_matched -> Break Semi .)
    Continue        reduce using rule 31 (statement_matched -> Break Semi .)
    Int             reduce using rule 31 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 31 (statement_matched -> Break Semi .)
    Integer         reduce using rule 31 (statement_matched -> Break Semi .)
    LParen          reduce using rule 31 (statement_matched -> Break Semi .)
    Minus           reduce using rule 31 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 31 (statement_matched -> Break Semi .)
    Not             reduce using rule 31 (statement_matched -> Break Semi .)
    Semi            reduce using rule 31 (statement_matched -> Break Semi .)
    Else            reduce using rule 31 (statement_matched -> Break Semi .)


state 143

    (32) statement_matched -> Continue Semi .

    RBrace          reduce using rule 32 (statement_matched -> Continue Semi .)
    If              reduce using rule 32 (statement_matched -> Continue Semi .)
    While           reduce using rule 32 (statement_matched -> Continue Semi .)
    For             reduce using rule 32 (statement_matched -> Continue Semi .)
    Return          reduce using rule 32 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 32 (statement_matched -> Continue Semi .)
    Break           reduce using rule 32 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 32 (statement_matched -> Continue Semi .)
    Int             reduce using rule 32 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 32 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 32 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 32 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 32 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 32 (statement_matched -> Continue Semi .)
    Not             reduce using rule 32 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 32 (statement_matched -> Continue Semi .)
    Else            reduce using rule 32 (statement_matched -> Continue Semi .)


state 144

    (30) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 30 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 30 (statement_matched -> LBrace block RBrace .)


state 145

    (19) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (20) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 150


state 146

    (22) statement_matched -> While LParen expression . RParen statement_matched
    (23) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 151


state 147

    (24) statement_matched -> For LParen expression . Semi expression Semi expression RParen statement_matched
    (26) statement_unmatched -> For LParen expression . Semi expression Semi expression RParen statement_unmatched

    Semi            shift and go to state 152


state 148

    (25) statement_matched -> For LParen declaration . Semi expression Semi expression RParen statement_matched
    (27) statement_unmatched -> For LParen declaration . Semi expression Semi expression RParen statement_unmatched

    Semi            shift and go to state 153


state 149

    (28) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 28 (statement_matched -> Return expression Semi .)
    If              reduce using rule 28 (statement_matched -> Return expression Semi .)
    While           reduce using rule 28 (statement_matched -> Return expression Semi .)
    For             reduce using rule 28 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 28 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 28 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 28 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 28 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 28 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 28 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 28 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 28 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 28 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 28 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 28 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 28 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 28 (statement_matched -> Return expression Semi .)


state 150

    (19) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (20) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (21) statement_unmatched -> If LParen expression RParen . statement
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (17) statement -> . statement_matched
    (18) statement -> . statement_unmatched
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 123
    statement_matched              shift and go to state 154
    statement_unmatched            shift and go to state 122
    statement                      shift and go to state 155
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 151

    (22) statement_matched -> While LParen expression RParen . statement_matched
    (23) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 123
    statement_matched              shift and go to state 156
    statement_unmatched            shift and go to state 157
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 152

    (24) statement_matched -> For LParen expression Semi . expression Semi expression RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi . expression Semi expression RParen statement_unmatched
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 158
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 153

    (25) statement_matched -> For LParen declaration Semi . expression Semi expression RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi . expression Semi expression RParen statement_unmatched
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 159
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 154

    (19) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (20) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (17) statement -> statement_matched .

    Else            shift and go to state 160
    RBrace          reduce using rule 17 (statement -> statement_matched .)
    If              reduce using rule 17 (statement -> statement_matched .)
    While           reduce using rule 17 (statement -> statement_matched .)
    For             reduce using rule 17 (statement -> statement_matched .)
    Return          reduce using rule 17 (statement -> statement_matched .)
    LBrace          reduce using rule 17 (statement -> statement_matched .)
    Break           reduce using rule 17 (statement -> statement_matched .)
    Continue        reduce using rule 17 (statement -> statement_matched .)
    Int             reduce using rule 17 (statement -> statement_matched .)
    Identifier      reduce using rule 17 (statement -> statement_matched .)
    Integer         reduce using rule 17 (statement -> statement_matched .)
    LParen          reduce using rule 17 (statement -> statement_matched .)
    Minus           reduce using rule 17 (statement -> statement_matched .)
    BitNot          reduce using rule 17 (statement -> statement_matched .)
    Not             reduce using rule 17 (statement -> statement_matched .)
    Semi            reduce using rule 17 (statement -> statement_matched .)


state 155

    (21) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement .)


state 156

    (22) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 22 (statement_matched -> While LParen expression RParen statement_matched .)


state 157

    (23) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 23 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 158

    (24) statement_matched -> For LParen expression Semi expression . Semi expression RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression . Semi expression RParen statement_unmatched

    Semi            shift and go to state 161


state 159

    (25) statement_matched -> For LParen declaration Semi expression . Semi expression RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression . Semi expression RParen statement_unmatched

    Semi            shift and go to state 162


state 160

    (19) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (20) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 123
    statement_matched              shift and go to state 163
    statement_unmatched            shift and go to state 164
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 161

    (24) statement_matched -> For LParen expression Semi expression Semi . expression RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression Semi . expression RParen statement_unmatched
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 165
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 162

    (25) statement_matched -> For LParen declaration Semi expression Semi . expression RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression Semi . expression RParen statement_unmatched
    (45) expression -> . assignment
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 166
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 163

    (19) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 19 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 164

    (20) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 165

    (24) statement_matched -> For LParen expression Semi expression Semi expression . RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 167


state 166

    (25) statement_matched -> For LParen declaration Semi expression Semi expression . RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 168


state 167

    (24) statement_matched -> For LParen expression Semi expression Semi expression RParen . statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression Semi expression RParen . statement_unmatched
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 123
    statement_matched              shift and go to state 169
    statement_unmatched            shift and go to state 170
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 168

    (25) statement_matched -> For LParen declaration Semi expression Semi expression RParen . statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen . statement_unmatched
    (19) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (22) statement_matched -> . While LParen expression RParen statement_matched
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . Return expression Semi
    (29) statement_matched -> . opt_expression Semi
    (30) statement_matched -> . LBrace block RBrace
    (31) statement_matched -> . Break Semi
    (32) statement_matched -> . Continue Semi
    (20) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement
    (23) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) opt_expression -> . expression
    (34) opt_expression -> . empty
    (45) expression -> . assignment
    (1) empty -> .
    (46) assignment -> . conditional
    (68) assignment -> . postfix Assign expression
    (47) conditional -> . logical_or
    (85) conditional -> . logical_or Question expression Colon conditional
    (58) postfix -> . primary
    (63) postfix -> . Identifier LParen expression_list RParen
    (64) postfix -> . postfix LBracket expression RBracket
    (48) logical_or -> . logical_and
    (69) logical_or -> . logical_or Or logical_and
    (86) primary -> . Integer
    (87) primary -> . Identifier
    (88) primary -> . LParen expression RParen
    (49) logical_and -> . bit_or
    (70) logical_and -> . logical_and And bit_or
    (50) bit_or -> . xor
    (71) bit_or -> . bit_or BitOr xor
    (51) xor -> . bit_and
    (72) xor -> . xor Xor bit_and
    (52) bit_and -> . equality
    (73) bit_and -> . bit_and BitAnd equality
    (53) equality -> . relational
    (74) equality -> . equality NotEqual relational
    (75) equality -> . equality Equal relational
    (54) relational -> . additive
    (76) relational -> . relational Less additive
    (77) relational -> . relational Greater additive
    (78) relational -> . relational LessEqual additive
    (79) relational -> . relational GreaterEqual additive
    (55) additive -> . multiplicative
    (80) additive -> . additive Plus multiplicative
    (81) additive -> . additive Minus multiplicative
    (56) multiplicative -> . unary
    (82) multiplicative -> . multiplicative Mul unary
    (83) multiplicative -> . multiplicative Div unary
    (84) multiplicative -> . multiplicative Mod unary
    (57) unary -> . postfix
    (65) unary -> . Minus unary
    (66) unary -> . BitNot unary
    (67) unary -> . Not unary

    If              shift and go to state 124
    While           shift and go to state 125
    For             shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 116
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 16
    Integer         shift and go to state 25
    LParen          shift and go to state 23
    Minus           shift and go to state 33
    BitNot          shift and go to state 35
    Not             shift and go to state 36

    expression                     shift and go to state 123
    statement_matched              shift and go to state 171
    statement_unmatched            shift and go to state 172
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 18
    conditional                    shift and go to state 19
    postfix                        shift and go to state 20
    logical_or                     shift and go to state 21
    primary                        shift and go to state 22
    logical_and                    shift and go to state 24
    bit_or                         shift and go to state 26
    xor                            shift and go to state 27
    bit_and                        shift and go to state 28
    equality                       shift and go to state 29
    relational                     shift and go to state 30
    additive                       shift and go to state 31
    multiplicative                 shift and go to state 32
    unary                          shift and go to state 34

state 169

    (24) statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)


state 170

    (26) statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)


state 171

    (25) statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)


state 172

    (27) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LParen in state 16 resolved as shift
WARNING: shift/reduce conflict for Minus in state 31 resolved as shift
WARNING: shift/reduce conflict for Minus in state 92 resolved as shift
WARNING: shift/reduce conflict for Minus in state 93 resolved as shift
WARNING: shift/reduce conflict for Minus in state 94 resolved as shift
WARNING: shift/reduce conflict for Minus in state 95 resolved as shift
WARNING: reduce/reduce conflict in state 104 resolved using rule (params -> type Identifier dim_list)
WARNING: rejected rule (declaration -> type Identifier dim_list) in state 104
